---
title: "AtCoder Beginner Contest 311 | A - F"
date: 2023-07-23T00:00:00+09:00
tags: ["atcoder", "competitive-programming"]
ShowToc: true
draft: false
---

[ABC 311 링크](https://atcoder.jp/contests/abc311/tasks)

이번 콘테스트 D까지 밖에 못풀었고 E번 거의 풀다가 마지막에 시간이 부족했습니다. 더 잘할 수 있었는데 못해서 아쉬움이 많이 남았고 D번에서 시간 많이 뺏긴게 아쉽네요. 

다음 회차에서는 대회 시작 2시간 전에 버추얼 하나 돌면서 warm-up time 을 가져와야 겠어요. **전체적으로 문제는 잘 나왔다고 생각하해서 풀어두면 배울점이 많을 것 같습니다.**

![My ABC311 Score](/images/abc311/abc311_score.png)

--------

## A - First ABC
A,B,C로 이루어진 일련의 문자열이 있는데 가장 처음으로 A,B,C가 모두 등장한 곳을 찾는 문제입니다. 바로 구현하면 됩니다.

```shell
# Input
5
ACABB

# Output
4
```

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pll = pair<ll, ll>;

const int INF = 1e9 + 5;
const ll llINF = 1e18;

bool check[3];
int n;
string s;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n;
    cin >> s;

    for(int i = 0; i < n; i++) {
        check[s[i] - 'A'] = true;
        bool flag = true;
        for(bool l : check) {
            if(!l) flag = false;
        }
        if(flag) {
            cout << i+1 << endl;
            return 0;
        }
    }

    return 0;
}
```

--------

## B - Vacation Together
%%N%% 명의 사람이 %%D%%일간의 스케쥴 표를 작성하는 데요. 시간이 비어서 프리인 날은 `o`로 표기하고 선약이 있거나 바쁜 날은 `x`로 표기합니다. 이제 휴가로 해외여행을 가려고 하는데 **가장 긴 연속적인 프리**인 날을 찾아야 합니다. %%N%%이 최대 100으로 작기 때문에 바로 구현하면 됩니다.

```shell
# Sample Input
3 5
xooox
oooxx
oooxo

## Sample Output
2
```

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pll = pair<ll, ll>;

const int INF = 1e9 + 5;
const ll llINF = 1e18;

int n, d;
vector<string> arr;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> d;
    for(int i = 0; i < n; i++) {
        string x;
        cin >> x;
        arr.push_back(x);
    }

    int ans = 0;
    int a = 0;
    for(int i = 0; i < d; i++) {
        bool flag = true;
        bool prev = true;
        for(int j = 0; j < n; j++) {
            if(arr[j][i] == 'x') {
                flag = false;
                break;
            }
            if(j > 0) {
                if(arr[j-1][i] == 'x') {
                    prev = false;
                    break;
                }
            }
        }
        if(prev && flag) {
            a++;
            ans = max(ans, a);
        } else if(flag) {
            a = 1;
            ans = max(ans, a);
        }
        if(!flag) {
            a = 0;
        }
    }
    
    cout << ans << endl;

    return 0;
}
```

--------

## C - Find It!
방향 그래프 %%G%%가 있고 %%N%%개의 정점과 %%N%%의 간선이 입력으로 주어집니다. 그래프에서 사이클(Cycle)이 반드시 존재하도록 입력으로 주어지는데요. 그래프에서 사이클을 찾아서 출력하는 문제입니다.

아래 그림처럼 그래프가 추어졌다면 **0 4 2** 혹은 **4 2 0**를 출력하면 됩니다. 사이클에 속한 정점을 순서대로 출력하되 시작 정점은 마음대로 정하면 됩니다.

![Find It!](/images/abc311/graph.png)

먼저 그래프에서 사이클이 존재하는지 찾는 건 DFS를 돌면서 이미 방문한 정점을 다시 방문했는가? 를 검사하면 쉽게 찾을 수 있습니다. 여기서 문제에서는 사이클에 속한 집합의 정점을 순서대로 출력하도록 요구하는데요. 

저는 사이클을 찾는 코드에서 **이번 정점이 몇 번 정점으로 부터 왔는지, 즉 부모가 누구인지**를 기록하고 정답을 출력해야 하는 시점에 부모를 타고 올라가서 사이클을 구하는 방식으로 구했습니다.

```cpp
void dfs(int node) {
    vis[node] = true;
    for(int v : adj[node]) {
        if(!vis[v]) {
            parents[v] = node;
            dfs(v);
        } else if(!finished[v]) {
            parents[v] = node;
            print_cycle(node);
        }
    }
    finished[node] = true;
}
```

사이클을 구하는 코드 영역입니다. 만약 아직 방문이 완료되지 않은 노드라면 사이클이라고 판단하고 현재 노드의 부모노드를 계속 따라가면서 사이클을 구합니다. 이런 방식을 사용하면 반드시 어떤 노드의 부모는 현재 노드가 되죠.

```cpp
void print_cycle(int node) {
    vector<int> ans;
    ans.push_back(node);
    int cur = parents[node];
    while(cur != node) {
        ans.push_back(cur);
        cur = parents[cur];
    }
 
    reverse(ans.begin(), ans.end());
    cout << ans.size() << endl;
    for(auto c : ans) {
        cout << c << " ";
    }
    exit(0);
}
```

저는 이 문제를 제가 알던 지식을 사용해서 풀어가지고 코드라인이 조금 길었는데요. 이 바닥의 고수들은 이렇게 짧고 간결하게 풀었씁니다. [아래 코드는 IBory님이 제출하신 코드입니다](https://atcoder.jp/contests/abc311/submissions/43833807)

```cpp
#include <bits/stdc++.h>
#define pii pair<ll, ll>
typedef long long ll;
using namespace std;

const int MAX = 200007;
int A[MAX], V[MAX];

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	int N;
	cin >> N;
	for (int i = 1; i <= N; ++i) cin >> A[i];
	vector<int> ans;
	int cur = 1;
	while (!V[cur]) {
		V[cur] = 1;
		ans.push_back(cur);
		cur = A[cur];
	}

	reverse(ans.begin(), ans.end());
	while (ans.back() != cur) ans.pop_back();
	cout << ans.size() << '\n';
	reverse(ans.begin(), ans.end());
	for (int n : ans) cout << n << ' ';
	return 0;
}
```

## D - Grid Ice Floor
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.

## E - Defect free Squares
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.

## F - Yet Another Grid Task
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.

## G - One More Grid Task
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.