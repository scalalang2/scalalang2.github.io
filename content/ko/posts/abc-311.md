---
title: "AtCoder Beginner Contest 311 | A - G"
date: 2023-07-23T00:00:00+09:00
tags: ["atcoder", "competitive-programming"]
ShowToc: true
draft: false
---

[ABC 311 링크](https://atcoder.jp/contests/abc311/tasks)

이번 콘테스트 D까지 밖에 못풀었고 E번 거의 풀다가 마지막에 시간이 부족했습니다. 더 잘할 수 있었는데 못해서 아쉬움이 많이 남았고 D번에서 시간 많이 뺏긴게 아쉽네요. 

다음 회차에서는 대회 시작 2시간 전에 버추얼 하나 돌면서 warm-up time 을 가져와야 겠어요. **전체적으로 문제는 잘 나왔다고 생각하해서 풀어두면 배울점이 많을 것 같습니다.**

![My ABC311 Score](/images/abc311/abc311_score.png)

--------

## A - First ABC
A,B,C로 이루어진 일련의 문자열이 있는데 가장 처음으로 A,B,C가 모두 등장한 곳을 찾는 문제입니다. 바로 구현하면 됩니다.

```shell
# Input
5
ACABB

# Output
4
```

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pll = pair<ll, ll>;

const int INF = 1e9 + 5;
const ll llINF = 1e18;

bool check[3];
int n;
string s;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n;
    cin >> s;

    for(int i = 0; i < n; i++) {
        check[s[i] - 'A'] = true;
        bool flag = true;
        for(bool l : check) {
            if(!l) flag = false;
        }
        if(flag) {
            cout << i+1 << endl;
            return 0;
        }
    }

    return 0;
}
```

--------

## B - Vacation Together
%%N%% 명의 사람이 %%D%%일간의 스케쥴 표를 작성하는 데요. 시간이 비어서 프리인 날은 `o`로 표기하고 선약이 있거나 바쁜 날은 `x`로 표기합니다. 이제 휴가로 해외여행을 가려고 하는데 **가장 긴 연속적인 프리**인 날을 찾아야 합니다. %%N%%이 최대 100으로 작기 때문에 바로 구현하면 됩니다.

```shell
# Sample Input
3 5
xooox
oooxx
oooxo

## Sample Output
2
```

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pll = pair<ll, ll>;

const int INF = 1e9 + 5;
const ll llINF = 1e18;

int n, d;
vector<string> arr;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> d;
    for(int i = 0; i < n; i++) {
        string x;
        cin >> x;
        arr.push_back(x);
    }

    int ans = 0;
    int a = 0;
    for(int i = 0; i < d; i++) {
        bool flag = true;
        bool prev = true;
        for(int j = 0; j < n; j++) {
            if(arr[j][i] == 'x') {
                flag = false;
                break;
            }
            if(j > 0) {
                if(arr[j-1][i] == 'x') {
                    prev = false;
                    break;
                }
            }
        }
        if(prev && flag) {
            a++;
            ans = max(ans, a);
        } else if(flag) {
            a = 1;
            ans = max(ans, a);
        }
        if(!flag) {
            a = 0;
        }
    }
    
    cout << ans << endl;

    return 0;
}
```

--------

## C - Find It!
방향 그래프 %%G%%가 있고 %%N%%개의 정점과 %%N%%의 간선이 입력으로 주어집니다. 그래프에서 사이클(Cycle)이 반드시 존재하도록 입력으로 주어지는데요. 그래프에서 사이클을 찾아서 출력하는 문제입니다.

아래 그림처럼 그래프가 추어졌다면 **0 4 2** 혹은 **4 2 0**를 출력하면 됩니다. 사이클에 속한 정점을 순서대로 출력하되 시작 정점은 마음대로 정하면 됩니다.

![Find It!](/images/abc311/graph.png)

먼저 그래프에서 사이클이 존재하는지 찾는 건 DFS를 돌면서 이미 방문한 정점을 다시 방문했는가? 를 검사하면 쉽게 찾을 수 있습니다. 여기서 문제는 사이클에 속한 집합의 정점을 순서대로 출력하는 건데요. 

## D - Grid Ice Floor
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.

## E - Defect free Squares
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.

## F - Yet Another Grid Task
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.

## G - One More Grid Task
> 열심히 쓰는 중.. 곧 풀이를 올릴거에요.