---
title: "HTTP/2와 gRPC"
date: 2023-07-24T00:00:00+09:00
tags: ["http/2", "grpc", "kubernetes"]
ShowToc: true
---

## 개요

요즘 마이크로서비스 아키텍처를 채용하는 많은 조직들이 gRPC 프로토콜을 내부 서비스 통신용으로 많이 사용하고 있습니다. 
gRPC는 HTTP/2를 전송 프로토콜로 사용하는 RPC 프레임워크인데요. 그래서, 우리가 웹 서버를 개발할 때 HTTP 프로토콜의 기본 동작을 잘 알아야 하는 것 처럼
**gRPC를 다룬다면 HTTP/2를 이해할 필요가 있습니다.**

HTTP/2 프로토콜의 목적은 HTTP/1.1의 성능을 개선하는 겁니다. ① 하나의 커넥션에서 다수의 요청과 응답을 처리하는 멀티플렉싱 도입과 ② HTTP 헤더 필드를 효율적으로 압축해서 프로토콜 오버헤드를 줄이는 것, ③ 클라이언트가 우선순위 트리를 만들어서 요청을 보내면 서버가 우선순위에 따라 응답을 보내는 서버 푸시 기능, ➃ HTTP/1.1 로 맺어진 커넥션을 HTTP/2로 격상하자고 네고하는(ALPN) 기능이 주요 변경 사항입니다.

변화가 많은 것 같아 걱정하지 않아도 됩니다. HTTP의 컨셉 대부분은 그대로 보존되어 있어서 HTTP 메서드, 응답 코드, 헤더 필드 등 친숙한 개념들은 그대로 남아있습니다.

## 바이너리 프레임 포맷 (Binary Frame Format)
HTTP 프로토콜은 데이터를 전송할 때 아래처럼 텍스트 포맷을 이용합니다. 

```sh
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

사람이 읽고 해석하기는 쉬운 포맷이죠. 그런데 웹서버가 요청을 받는 형태를 보면 한 명의 유저가 브라우저로 접속하면 이미지 같은 정적 컨텐츠부터 필요에 따라 다수의 API 요청을 서버로 전달합니다. 이 과정에서 무거운 헤더값이 계속 중복되기도 하죠. 특히 쿠키값이 많이 포함되면 본문보다 헤더가 더 무거운 경우도 자주 있습니다. 또한, HTTP/1.1 에서 KeepAlive 옵션이 추가되서 커넥션을 재사용하고 파이프라이닝으로 요청을 병렬적으로 보낼 수 있는 등 일련의 개선은 있었으나 HOL(Head Of Line) Blocking 문제로 응답이 지연되는 경우도 있습니다.

이런 문제를 조금이라도 줄이기 위해서 어떤 일을 해왔냐면 CDN과 브라우저 캐시를 이용하고, CSS/Javascript 파일을 압축해서 